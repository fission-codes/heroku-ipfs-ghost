#!/usr/bin/env node
// Ghost Configuration for Heroku

const fs = require('fs');
const path = require('path');
const url = require('url');

const envValues = require('./common/env-values');
const appRoot = path.join(__dirname, '..');

function createConfig() {
  let fileStorage = false;
  let storage = {};

  // When deploying from git rather then a Heroku deploy button, Heroku doesn't
  // read app.json and doesn't set the environment variables configured there.
  // The `PUBLIC_URL` envvar is required, so if it's missing we know app.json
  // was skipped, and we read it explictly.
  if (!process.env.PUBLIC_URL) {
    const appJson = JSON.parse(fs.readFileSync(`${appRoot}/app.json`, 'utf8'));
    process.env.PUBLIC_URL = appJson.env.PUBLIC_URL.value;
    process.env.IPFS_GATEWAY_URL = appJson.env.IPFS_GATEWAY_URL.value;
  }

  if(!!process.env.INTERPLANETARY_FISSION_USERNAME && !!process.env.INTERPLANETARY_FISSION_PASSWORD) {
    fileStorage = true;
    let storageOptions = {
      username: process.env.INTERPLANETARY_FISSION_USERNAME,
      password: process.env.INTERPLANETARY_FISSION_PASSWORD
    };

    if(!!process.env.INTERPLANETARY_FISSION_URL) {
      storageOptions.apiURL = process.env.INTERPLANETARY_FISSION_URL;
    }

    if(!!process.env.IPFS_GATEWAY_URL) {
      storageOptions.gatewayURL = process.env.IPFS_GATEWAY_URL;
    }

    storage = {
      "active": "ghost-storage-adapter-ipfs",
      "ghost-storage-adapter-ipfs": storageOptions
    };
  }

  const config = {
    url: process.env.PUBLIC_URL,
    logging: {
      level: "info",
      transports: ["stdout"]
    },
    mail: {
      transport: 'SMTP',
      options: {
        service: 'Mailgun',
        auth: {
          user: process.env.MAILGUN_SMTP_LOGIN,
          pass: process.env.MAILGUN_SMTP_PASSWORD
        }
      }
    },
    fileStorage: fileStorage,
    storage: storage,
    database: {
      client: 'mysql',
      connection: getMysqlConfig(envValues.mysqlDatabaseUrl),
      pool: { min: 0, max: 5 },
      debug: false
    },
    server: {
      host: '0.0.0.0',
      port: process.env.PORT
    },
    paths: {
      contentPath: path.join(appRoot, '/content/')
    }
  };

  return config;
}

function getMysqlConfig(connectionUrl) {
  if (connectionUrl === null) {
    return {};
  }

  const dbConfig = url.parse(connectionUrl);
  if (dbConfig === null) {
    return {};
  }

  const dbAuth = dbConfig.auth ? dbConfig.auth.split(':', 2) : [];
  const [dbUser, dbPassword] = dbAuth;

  const dbName = (dbConfig.pathname === null) ? 'ghost' : dbConfig.pathname.split('/', 2)[1];

  const dbConnection = {
    host: dbConfig.hostname,
    port: dbConfig.port || '3306',
    user: dbUser,
    password: dbPassword,
    database: dbName
  };

  return dbConnection;
}

const configContents = JSON.stringify(createConfig(), null, 2);
fs.writeFileSync(path.join(appRoot, 'config.production.json'), configContents);
